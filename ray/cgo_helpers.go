// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 05 Nov 2019 17:44:23 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package ray

/*
#include "raylib.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocVector2Memory allocates memory for type C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector2Value = unsafe.Sizeof([1]C.Vector2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector2) Ref() *C.Vector2 {
	if x == nil {
		return nil
	}
	return x.ref29ca61a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector2) Free() {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
	}
}

// NewVector2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector2Ref(ref unsafe.Pointer) *Vector2 {
	if ref == nil {
		return nil
	}
	obj := new(Vector2)
	obj.ref29ca61a5 = (*C.Vector2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector2) PassRef() (*C.Vector2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29ca61a5 != nil {
		return x.ref29ca61a5, nil
	}
	mem29ca61a5 := allocVector2Memory(1)
	ref29ca61a5 := (*C.Vector2)(mem29ca61a5)
	allocs29ca61a5 := new(cgoAllocMap)
	allocs29ca61a5.Add(mem29ca61a5)

	var cx_allocs *cgoAllocMap
	ref29ca61a5.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref29ca61a5.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cy_allocs)

	x.ref29ca61a5 = ref29ca61a5
	x.allocs29ca61a5 = allocs29ca61a5
	return ref29ca61a5, allocs29ca61a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector2) PassValue() (C.Vector2, *cgoAllocMap) {
	if x.ref29ca61a5 != nil {
		return *x.ref29ca61a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Vector2) Deref() {
	if x.ref29ca61a5 == nil {
		return
	}
	x.X = (float32)(x.ref29ca61a5.x)
	x.Y = (float32)(x.ref29ca61a5.y)
}

// allocVector3Memory allocates memory for type C.Vector3 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector3Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector3Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector3Value = unsafe.Sizeof([1]C.Vector3{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector3) Ref() *C.Vector3 {
	if x == nil {
		return nil
	}
	return x.ref5ecd5133
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector3) Free() {
	if x != nil && x.allocs5ecd5133 != nil {
		x.allocs5ecd5133.(*cgoAllocMap).Free()
		x.ref5ecd5133 = nil
	}
}

// NewVector3Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector3Ref(ref unsafe.Pointer) *Vector3 {
	if ref == nil {
		return nil
	}
	obj := new(Vector3)
	obj.ref5ecd5133 = (*C.Vector3)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector3) PassRef() (*C.Vector3, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ecd5133 != nil {
		return x.ref5ecd5133, nil
	}
	mem5ecd5133 := allocVector3Memory(1)
	ref5ecd5133 := (*C.Vector3)(mem5ecd5133)
	allocs5ecd5133 := new(cgoAllocMap)
	allocs5ecd5133.Add(mem5ecd5133)

	var cx_allocs *cgoAllocMap
	ref5ecd5133.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref5ecd5133.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	ref5ecd5133.z, cz_allocs = (C.float)(x.Z), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cz_allocs)

	x.ref5ecd5133 = ref5ecd5133
	x.allocs5ecd5133 = allocs5ecd5133
	return ref5ecd5133, allocs5ecd5133

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector3) PassValue() (C.Vector3, *cgoAllocMap) {
	if x.ref5ecd5133 != nil {
		return *x.ref5ecd5133, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Vector3) Deref() {
	if x.ref5ecd5133 == nil {
		return
	}
	x.X = (float32)(x.ref5ecd5133.x)
	x.Y = (float32)(x.ref5ecd5133.y)
	x.Z = (float32)(x.ref5ecd5133.z)
}

// allocVector4Memory allocates memory for type C.Vector4 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector4Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector4Value = unsafe.Sizeof([1]C.Vector4{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector4) Ref() *C.Vector4 {
	if x == nil {
		return nil
	}
	return x.refc0a9c490
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector4) Free() {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
	}
}

// NewVector4Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector4Ref(ref unsafe.Pointer) *Vector4 {
	if ref == nil {
		return nil
	}
	obj := new(Vector4)
	obj.refc0a9c490 = (*C.Vector4)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector4) PassRef() (*C.Vector4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0a9c490 != nil {
		return x.refc0a9c490, nil
	}
	memc0a9c490 := allocVector4Memory(1)
	refc0a9c490 := (*C.Vector4)(memc0a9c490)
	allocsc0a9c490 := new(cgoAllocMap)
	allocsc0a9c490.Add(memc0a9c490)

	var cx_allocs *cgoAllocMap
	refc0a9c490.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refc0a9c490.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	refc0a9c490.z, cz_allocs = (C.float)(x.Z), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cz_allocs)

	var cw_allocs *cgoAllocMap
	refc0a9c490.w, cw_allocs = (C.float)(x.W), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cw_allocs)

	x.refc0a9c490 = refc0a9c490
	x.allocsc0a9c490 = allocsc0a9c490
	return refc0a9c490, allocsc0a9c490

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector4) PassValue() (C.Vector4, *cgoAllocMap) {
	if x.refc0a9c490 != nil {
		return *x.refc0a9c490, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Vector4) Deref() {
	if x.refc0a9c490 == nil {
		return
	}
	x.X = (float32)(x.refc0a9c490.x)
	x.Y = (float32)(x.refc0a9c490.y)
	x.Z = (float32)(x.refc0a9c490.z)
	x.W = (float32)(x.refc0a9c490.w)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Quaternion) Ref() *C.Vector4 {
	if x == nil {
		return nil
	}
	return x.refc0a9c490
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Quaternion) Free() {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
	}
}

// NewQuaternionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQuaternionRef(ref unsafe.Pointer) *Quaternion {
	if ref == nil {
		return nil
	}
	obj := new(Quaternion)
	obj.refc0a9c490 = (*C.Vector4)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Quaternion) PassRef() (*C.Vector4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0a9c490 != nil {
		return x.refc0a9c490, nil
	}
	memc0a9c490 := allocVector4Memory(1)
	refc0a9c490 := (*C.Vector4)(memc0a9c490)
	allocsc0a9c490 := new(cgoAllocMap)
	allocsc0a9c490.Add(memc0a9c490)

	var cx_allocs *cgoAllocMap
	refc0a9c490.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refc0a9c490.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cy_allocs)

	var cz_allocs *cgoAllocMap
	refc0a9c490.z, cz_allocs = (C.float)(x.Z), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cz_allocs)

	var cw_allocs *cgoAllocMap
	refc0a9c490.w, cw_allocs = (C.float)(x.W), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cw_allocs)

	x.refc0a9c490 = refc0a9c490
	x.allocsc0a9c490 = allocsc0a9c490
	return refc0a9c490, allocsc0a9c490

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Quaternion) PassValue() (C.Vector4, *cgoAllocMap) {
	if x.refc0a9c490 != nil {
		return *x.refc0a9c490, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Quaternion) Deref() {
	if x.refc0a9c490 == nil {
		return
	}
	x.X = (float32)(x.refc0a9c490.x)
	x.Y = (float32)(x.refc0a9c490.y)
	x.Z = (float32)(x.refc0a9c490.z)
	x.W = (float32)(x.refc0a9c490.w)
}

// allocMatrixMemory allocates memory for type C.Matrix in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMatrixMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMatrixValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMatrixValue = unsafe.Sizeof([1]C.Matrix{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Matrix) Ref() *C.Matrix {
	if x == nil {
		return nil
	}
	return x.refff9f44f9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Matrix) Free() {
	if x != nil && x.allocsff9f44f9 != nil {
		x.allocsff9f44f9.(*cgoAllocMap).Free()
		x.refff9f44f9 = nil
	}
}

// NewMatrixRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMatrixRef(ref unsafe.Pointer) *Matrix {
	if ref == nil {
		return nil
	}
	obj := new(Matrix)
	obj.refff9f44f9 = (*C.Matrix)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Matrix) PassRef() (*C.Matrix, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff9f44f9 != nil {
		return x.refff9f44f9, nil
	}
	memff9f44f9 := allocMatrixMemory(1)
	refff9f44f9 := (*C.Matrix)(memff9f44f9)
	allocsff9f44f9 := new(cgoAllocMap)
	allocsff9f44f9.Add(memff9f44f9)

	var cm0_allocs *cgoAllocMap
	refff9f44f9.m0, cm0_allocs = (C.float)(x.M0), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm0_allocs)

	var cm4_allocs *cgoAllocMap
	refff9f44f9.m4, cm4_allocs = (C.float)(x.M4), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm4_allocs)

	var cm8_allocs *cgoAllocMap
	refff9f44f9.m8, cm8_allocs = (C.float)(x.M8), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm8_allocs)

	var cm12_allocs *cgoAllocMap
	refff9f44f9.m12, cm12_allocs = (C.float)(x.M12), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm12_allocs)

	var cm1_allocs *cgoAllocMap
	refff9f44f9.m1, cm1_allocs = (C.float)(x.M1), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm1_allocs)

	var cm5_allocs *cgoAllocMap
	refff9f44f9.m5, cm5_allocs = (C.float)(x.M5), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm5_allocs)

	var cm9_allocs *cgoAllocMap
	refff9f44f9.m9, cm9_allocs = (C.float)(x.M9), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm9_allocs)

	var cm13_allocs *cgoAllocMap
	refff9f44f9.m13, cm13_allocs = (C.float)(x.M13), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm13_allocs)

	var cm2_allocs *cgoAllocMap
	refff9f44f9.m2, cm2_allocs = (C.float)(x.M2), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm2_allocs)

	var cm6_allocs *cgoAllocMap
	refff9f44f9.m6, cm6_allocs = (C.float)(x.M6), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm6_allocs)

	var cm10_allocs *cgoAllocMap
	refff9f44f9.m10, cm10_allocs = (C.float)(x.M10), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm10_allocs)

	var cm14_allocs *cgoAllocMap
	refff9f44f9.m14, cm14_allocs = (C.float)(x.M14), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm14_allocs)

	var cm3_allocs *cgoAllocMap
	refff9f44f9.m3, cm3_allocs = (C.float)(x.M3), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm3_allocs)

	var cm7_allocs *cgoAllocMap
	refff9f44f9.m7, cm7_allocs = (C.float)(x.M7), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm7_allocs)

	var cm11_allocs *cgoAllocMap
	refff9f44f9.m11, cm11_allocs = (C.float)(x.M11), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm11_allocs)

	var cm15_allocs *cgoAllocMap
	refff9f44f9.m15, cm15_allocs = (C.float)(x.M15), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm15_allocs)

	x.refff9f44f9 = refff9f44f9
	x.allocsff9f44f9 = allocsff9f44f9
	return refff9f44f9, allocsff9f44f9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Matrix) PassValue() (C.Matrix, *cgoAllocMap) {
	if x.refff9f44f9 != nil {
		return *x.refff9f44f9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Matrix) Deref() {
	if x.refff9f44f9 == nil {
		return
	}
	x.M0 = (float32)(x.refff9f44f9.m0)
	x.M4 = (float32)(x.refff9f44f9.m4)
	x.M8 = (float32)(x.refff9f44f9.m8)
	x.M12 = (float32)(x.refff9f44f9.m12)
	x.M1 = (float32)(x.refff9f44f9.m1)
	x.M5 = (float32)(x.refff9f44f9.m5)
	x.M9 = (float32)(x.refff9f44f9.m9)
	x.M13 = (float32)(x.refff9f44f9.m13)
	x.M2 = (float32)(x.refff9f44f9.m2)
	x.M6 = (float32)(x.refff9f44f9.m6)
	x.M10 = (float32)(x.refff9f44f9.m10)
	x.M14 = (float32)(x.refff9f44f9.m14)
	x.M3 = (float32)(x.refff9f44f9.m3)
	x.M7 = (float32)(x.refff9f44f9.m7)
	x.M11 = (float32)(x.refff9f44f9.m11)
	x.M15 = (float32)(x.refff9f44f9.m15)
}

// allocColorMemory allocates memory for type C.Color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorValue = unsafe.Sizeof([1]C.Color{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Color) Ref() *C.Color {
	if x == nil {
		return nil
	}
	return x.refa79767ed
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Color) Free() {
	if x != nil && x.allocsa79767ed != nil {
		x.allocsa79767ed.(*cgoAllocMap).Free()
		x.refa79767ed = nil
	}
}

// NewColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewColorRef(ref unsafe.Pointer) *Color {
	if ref == nil {
		return nil
	}
	obj := new(Color)
	obj.refa79767ed = (*C.Color)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Color) PassRef() (*C.Color, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa79767ed != nil {
		return x.refa79767ed, nil
	}
	mema79767ed := allocColorMemory(1)
	refa79767ed := (*C.Color)(mema79767ed)
	allocsa79767ed := new(cgoAllocMap)
	allocsa79767ed.Add(mema79767ed)

	var cr_allocs *cgoAllocMap
	refa79767ed.r, cr_allocs = (C.uchar)(x.R), cgoAllocsUnknown
	allocsa79767ed.Borrow(cr_allocs)

	var cg_allocs *cgoAllocMap
	refa79767ed.g, cg_allocs = (C.uchar)(x.G), cgoAllocsUnknown
	allocsa79767ed.Borrow(cg_allocs)

	var cb_allocs *cgoAllocMap
	refa79767ed.b, cb_allocs = (C.uchar)(x.B), cgoAllocsUnknown
	allocsa79767ed.Borrow(cb_allocs)

	var ca_allocs *cgoAllocMap
	refa79767ed.a, ca_allocs = (C.uchar)(x.A), cgoAllocsUnknown
	allocsa79767ed.Borrow(ca_allocs)

	x.refa79767ed = refa79767ed
	x.allocsa79767ed = allocsa79767ed
	return refa79767ed, allocsa79767ed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Color) PassValue() (C.Color, *cgoAllocMap) {
	if x.refa79767ed != nil {
		return *x.refa79767ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Color) Deref() {
	if x.refa79767ed == nil {
		return
	}
	x.R = (byte)(x.refa79767ed.r)
	x.G = (byte)(x.refa79767ed.g)
	x.B = (byte)(x.refa79767ed.b)
	x.A = (byte)(x.refa79767ed.a)
}

// allocRectangleMemory allocates memory for type C.Rectangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectangleValue = unsafe.Sizeof([1]C.Rectangle{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rectangle) Ref() *C.Rectangle {
	if x == nil {
		return nil
	}
	return x.refcee8783a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Rectangle) Free() {
	if x != nil && x.allocscee8783a != nil {
		x.allocscee8783a.(*cgoAllocMap).Free()
		x.refcee8783a = nil
	}
}

// NewRectangleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectangleRef(ref unsafe.Pointer) *Rectangle {
	if ref == nil {
		return nil
	}
	obj := new(Rectangle)
	obj.refcee8783a = (*C.Rectangle)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rectangle) PassRef() (*C.Rectangle, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcee8783a != nil {
		return x.refcee8783a, nil
	}
	memcee8783a := allocRectangleMemory(1)
	refcee8783a := (*C.Rectangle)(memcee8783a)
	allocscee8783a := new(cgoAllocMap)
	allocscee8783a.Add(memcee8783a)

	var cx_allocs *cgoAllocMap
	refcee8783a.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocscee8783a.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refcee8783a.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocscee8783a.Borrow(cy_allocs)

	var cwidth_allocs *cgoAllocMap
	refcee8783a.width, cwidth_allocs = (C.float)(x.Width), cgoAllocsUnknown
	allocscee8783a.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	refcee8783a.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocscee8783a.Borrow(cheight_allocs)

	x.refcee8783a = refcee8783a
	x.allocscee8783a = allocscee8783a
	return refcee8783a, allocscee8783a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rectangle) PassValue() (C.Rectangle, *cgoAllocMap) {
	if x.refcee8783a != nil {
		return *x.refcee8783a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Rectangle) Deref() {
	if x.refcee8783a == nil {
		return
	}
	x.X = (float32)(x.refcee8783a.x)
	x.Y = (float32)(x.refcee8783a.y)
	x.Width = (float32)(x.refcee8783a.width)
	x.Height = (float32)(x.refcee8783a.height)
}

// allocImageMemory allocates memory for type C.Image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.Image{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Image) Ref() *C.Image {
	if x == nil {
		return nil
	}
	return x.ref4fc2b5b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Image) Free() {
	if x != nil && x.allocs4fc2b5b != nil {
		x.allocs4fc2b5b.(*cgoAllocMap).Free()
		x.ref4fc2b5b = nil
	}
}

// NewImageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageRef(ref unsafe.Pointer) *Image {
	if ref == nil {
		return nil
	}
	obj := new(Image)
	obj.ref4fc2b5b = (*C.Image)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Image) PassRef() (*C.Image, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4fc2b5b != nil {
		return x.ref4fc2b5b, nil
	}
	mem4fc2b5b := allocImageMemory(1)
	ref4fc2b5b := (*C.Image)(mem4fc2b5b)
	allocs4fc2b5b := new(cgoAllocMap)
	allocs4fc2b5b.Add(mem4fc2b5b)

	var cdata_allocs *cgoAllocMap
	ref4fc2b5b.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cdata_allocs)

	var cwidth_allocs *cgoAllocMap
	ref4fc2b5b.width, cwidth_allocs = (C.int)(x.Width), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref4fc2b5b.height, cheight_allocs = (C.int)(x.Height), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cheight_allocs)

	var cmipmaps_allocs *cgoAllocMap
	ref4fc2b5b.mipmaps, cmipmaps_allocs = (C.int)(x.Mipmaps), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cmipmaps_allocs)

	var cformat_allocs *cgoAllocMap
	ref4fc2b5b.format, cformat_allocs = (C.int)(x.Format), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cformat_allocs)

	x.ref4fc2b5b = ref4fc2b5b
	x.allocs4fc2b5b = allocs4fc2b5b
	return ref4fc2b5b, allocs4fc2b5b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Image) PassValue() (C.Image, *cgoAllocMap) {
	if x.ref4fc2b5b != nil {
		return *x.ref4fc2b5b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Image) Deref() {
	if x.ref4fc2b5b == nil {
		return
	}
	x.Data = (unsafe.Pointer)(unsafe.Pointer(x.ref4fc2b5b.data))
	x.Width = (int32)(x.ref4fc2b5b.width)
	x.Height = (int32)(x.ref4fc2b5b.height)
	x.Mipmaps = (int32)(x.ref4fc2b5b.mipmaps)
	x.Format = (int32)(x.ref4fc2b5b.format)
}

// allocTexture2DMemory allocates memory for type C.Texture2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTexture2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTexture2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTexture2DValue = unsafe.Sizeof([1]C.Texture2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Texture2D) Ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Texture2D) Free() {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
	}
}

// NewTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTexture2DRef(ref unsafe.Pointer) *Texture2D {
	if ref == nil {
		return nil
	}
	obj := new(Texture2D)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Texture2D) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		return x.ref3c51a40b, nil
	}
	mem3c51a40b := allocTexture2DMemory(1)
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.Width), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.Height), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.Mipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.Format), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	return ref3c51a40b, allocs3c51a40b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Texture2D) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Texture2D) Deref() {
	if x.ref3c51a40b == nil {
		return
	}
	x.Id = (uint32)(x.ref3c51a40b.id)
	x.Width = (int32)(x.ref3c51a40b.width)
	x.Height = (int32)(x.ref3c51a40b.height)
	x.Mipmaps = (int32)(x.ref3c51a40b.mipmaps)
	x.Format = (int32)(x.ref3c51a40b.format)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Texture) Ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Texture) Free() {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
	}
}

// NewTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextureRef(ref unsafe.Pointer) *Texture {
	if ref == nil {
		return nil
	}
	obj := new(Texture)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Texture) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		return x.ref3c51a40b, nil
	}
	mem3c51a40b := allocTexture2DMemory(1)
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.Width), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.Height), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.Mipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.Format), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	return ref3c51a40b, allocs3c51a40b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Texture) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Texture) Deref() {
	if x.ref3c51a40b == nil {
		return
	}
	x.Id = (uint32)(x.ref3c51a40b.id)
	x.Width = (int32)(x.ref3c51a40b.width)
	x.Height = (int32)(x.ref3c51a40b.height)
	x.Mipmaps = (int32)(x.ref3c51a40b.mipmaps)
	x.Format = (int32)(x.ref3c51a40b.format)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextureCubemap) Ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextureCubemap) Free() {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
	}
}

// NewTextureCubemapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextureCubemapRef(ref unsafe.Pointer) *TextureCubemap {
	if ref == nil {
		return nil
	}
	obj := new(TextureCubemap)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextureCubemap) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		return x.ref3c51a40b, nil
	}
	mem3c51a40b := allocTexture2DMemory(1)
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.Width), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.Height), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.Mipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.Format), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	return ref3c51a40b, allocs3c51a40b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextureCubemap) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TextureCubemap) Deref() {
	if x.ref3c51a40b == nil {
		return
	}
	x.Id = (uint32)(x.ref3c51a40b.id)
	x.Width = (int32)(x.ref3c51a40b.width)
	x.Height = (int32)(x.ref3c51a40b.height)
	x.Mipmaps = (int32)(x.ref3c51a40b.mipmaps)
	x.Format = (int32)(x.ref3c51a40b.format)
}

// allocRenderTexture2DMemory allocates memory for type C.RenderTexture2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderTexture2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderTexture2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderTexture2DValue = unsafe.Sizeof([1]C.RenderTexture2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderTexture2D) Ref() *C.RenderTexture2D {
	if x == nil {
		return nil
	}
	return x.ref2f94e9e3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderTexture2D) Free() {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
	}
}

// NewRenderTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderTexture2DRef(ref unsafe.Pointer) *RenderTexture2D {
	if ref == nil {
		return nil
	}
	obj := new(RenderTexture2D)
	obj.ref2f94e9e3 = (*C.RenderTexture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderTexture2D) PassRef() (*C.RenderTexture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f94e9e3 != nil {
		return x.ref2f94e9e3, nil
	}
	mem2f94e9e3 := allocRenderTexture2DMemory(1)
	ref2f94e9e3 := (*C.RenderTexture2D)(mem2f94e9e3)
	allocs2f94e9e3 := new(cgoAllocMap)
	allocs2f94e9e3.Add(mem2f94e9e3)

	var cid_allocs *cgoAllocMap
	ref2f94e9e3.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cid_allocs)

	var ctexture_allocs *cgoAllocMap
	ref2f94e9e3.texture, ctexture_allocs = x.Texture.PassValue()
	allocs2f94e9e3.Borrow(ctexture_allocs)

	var cdepth_allocs *cgoAllocMap
	ref2f94e9e3.depth, cdepth_allocs = x.Depth.PassValue()
	allocs2f94e9e3.Borrow(cdepth_allocs)

	var cdepthTexture_allocs *cgoAllocMap
	ref2f94e9e3.depthTexture, cdepthTexture_allocs = (C._Bool)(x.DepthTexture), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cdepthTexture_allocs)

	x.ref2f94e9e3 = ref2f94e9e3
	x.allocs2f94e9e3 = allocs2f94e9e3
	return ref2f94e9e3, allocs2f94e9e3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderTexture2D) PassValue() (C.RenderTexture2D, *cgoAllocMap) {
	if x.ref2f94e9e3 != nil {
		return *x.ref2f94e9e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderTexture2D) Deref() {
	if x.ref2f94e9e3 == nil {
		return
	}
	x.Id = (uint32)(x.ref2f94e9e3.id)
	x.Texture = *NewTexture2DRef(unsafe.Pointer(&x.ref2f94e9e3.texture))
	x.Depth = *NewTexture2DRef(unsafe.Pointer(&x.ref2f94e9e3.depth))
	x.DepthTexture = (bool)(x.ref2f94e9e3.depthTexture)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderTexture) Ref() *C.RenderTexture2D {
	if x == nil {
		return nil
	}
	return x.ref2f94e9e3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderTexture) Free() {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
	}
}

// NewRenderTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderTextureRef(ref unsafe.Pointer) *RenderTexture {
	if ref == nil {
		return nil
	}
	obj := new(RenderTexture)
	obj.ref2f94e9e3 = (*C.RenderTexture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderTexture) PassRef() (*C.RenderTexture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f94e9e3 != nil {
		return x.ref2f94e9e3, nil
	}
	mem2f94e9e3 := allocRenderTexture2DMemory(1)
	ref2f94e9e3 := (*C.RenderTexture2D)(mem2f94e9e3)
	allocs2f94e9e3 := new(cgoAllocMap)
	allocs2f94e9e3.Add(mem2f94e9e3)

	var cid_allocs *cgoAllocMap
	ref2f94e9e3.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cid_allocs)

	var ctexture_allocs *cgoAllocMap
	ref2f94e9e3.texture, ctexture_allocs = x.Texture.PassValue()
	allocs2f94e9e3.Borrow(ctexture_allocs)

	var cdepth_allocs *cgoAllocMap
	ref2f94e9e3.depth, cdepth_allocs = x.Depth.PassValue()
	allocs2f94e9e3.Borrow(cdepth_allocs)

	var cdepthTexture_allocs *cgoAllocMap
	ref2f94e9e3.depthTexture, cdepthTexture_allocs = (C._Bool)(x.DepthTexture), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cdepthTexture_allocs)

	x.ref2f94e9e3 = ref2f94e9e3
	x.allocs2f94e9e3 = allocs2f94e9e3
	return ref2f94e9e3, allocs2f94e9e3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderTexture) PassValue() (C.RenderTexture2D, *cgoAllocMap) {
	if x.ref2f94e9e3 != nil {
		return *x.ref2f94e9e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderTexture) Deref() {
	if x.ref2f94e9e3 == nil {
		return
	}
	x.Id = (uint32)(x.ref2f94e9e3.id)
	x.Texture = *NewTexture2DRef(unsafe.Pointer(&x.ref2f94e9e3.texture))
	x.Depth = *NewTexture2DRef(unsafe.Pointer(&x.ref2f94e9e3.depth))
	x.DepthTexture = (bool)(x.ref2f94e9e3.depthTexture)
}

// allocNPatchInfoMemory allocates memory for type C.NPatchInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNPatchInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNPatchInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNPatchInfoValue = unsafe.Sizeof([1]C.NPatchInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *NPatchInfo) Ref() *C.NPatchInfo {
	if x == nil {
		return nil
	}
	return x.ref78104a03
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *NPatchInfo) Free() {
	if x != nil && x.allocs78104a03 != nil {
		x.allocs78104a03.(*cgoAllocMap).Free()
		x.ref78104a03 = nil
	}
}

// NewNPatchInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewNPatchInfoRef(ref unsafe.Pointer) *NPatchInfo {
	if ref == nil {
		return nil
	}
	obj := new(NPatchInfo)
	obj.ref78104a03 = (*C.NPatchInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *NPatchInfo) PassRef() (*C.NPatchInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref78104a03 != nil {
		return x.ref78104a03, nil
	}
	mem78104a03 := allocNPatchInfoMemory(1)
	ref78104a03 := (*C.NPatchInfo)(mem78104a03)
	allocs78104a03 := new(cgoAllocMap)
	allocs78104a03.Add(mem78104a03)

	var csourceRec_allocs *cgoAllocMap
	ref78104a03.sourceRec, csourceRec_allocs = x.SourceRec.PassValue()
	allocs78104a03.Borrow(csourceRec_allocs)

	var cleft_allocs *cgoAllocMap
	ref78104a03.left, cleft_allocs = (C.int)(x.Left), cgoAllocsUnknown
	allocs78104a03.Borrow(cleft_allocs)

	var ctop_allocs *cgoAllocMap
	ref78104a03.top, ctop_allocs = (C.int)(x.Top), cgoAllocsUnknown
	allocs78104a03.Borrow(ctop_allocs)

	var cright_allocs *cgoAllocMap
	ref78104a03.right, cright_allocs = (C.int)(x.Right), cgoAllocsUnknown
	allocs78104a03.Borrow(cright_allocs)

	var cbottom_allocs *cgoAllocMap
	ref78104a03.bottom, cbottom_allocs = (C.int)(x.Bottom), cgoAllocsUnknown
	allocs78104a03.Borrow(cbottom_allocs)

	var c_type_allocs *cgoAllocMap
	ref78104a03._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocs78104a03.Borrow(c_type_allocs)

	x.ref78104a03 = ref78104a03
	x.allocs78104a03 = allocs78104a03
	return ref78104a03, allocs78104a03

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x NPatchInfo) PassValue() (C.NPatchInfo, *cgoAllocMap) {
	if x.ref78104a03 != nil {
		return *x.ref78104a03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *NPatchInfo) Deref() {
	if x.ref78104a03 == nil {
		return
	}
	x.SourceRec = *NewRectangleRef(unsafe.Pointer(&x.ref78104a03.sourceRec))
	x.Left = (int32)(x.ref78104a03.left)
	x.Top = (int32)(x.ref78104a03.top)
	x.Right = (int32)(x.ref78104a03.right)
	x.Bottom = (int32)(x.ref78104a03.bottom)
	x.Type = (int32)(x.ref78104a03._type)
}

// allocCharInfoMemory allocates memory for type C.CharInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCharInfoValue = unsafe.Sizeof([1]C.CharInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CharInfo) Ref() *C.CharInfo {
	if x == nil {
		return nil
	}
	return x.ref702c36c0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CharInfo) Free() {
	if x != nil && x.allocs702c36c0 != nil {
		x.allocs702c36c0.(*cgoAllocMap).Free()
		x.ref702c36c0 = nil
	}
}

// NewCharInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCharInfoRef(ref unsafe.Pointer) *CharInfo {
	if ref == nil {
		return nil
	}
	obj := new(CharInfo)
	obj.ref702c36c0 = (*C.CharInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CharInfo) PassRef() (*C.CharInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref702c36c0 != nil {
		return x.ref702c36c0, nil
	}
	mem702c36c0 := allocCharInfoMemory(1)
	ref702c36c0 := (*C.CharInfo)(mem702c36c0)
	allocs702c36c0 := new(cgoAllocMap)
	allocs702c36c0.Add(mem702c36c0)

	var cvalue_allocs *cgoAllocMap
	ref702c36c0.value, cvalue_allocs = (C.int)(x.Value), cgoAllocsUnknown
	allocs702c36c0.Borrow(cvalue_allocs)

	var coffsetX_allocs *cgoAllocMap
	ref702c36c0.offsetX, coffsetX_allocs = (C.int)(x.OffsetX), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetX_allocs)

	var coffsetY_allocs *cgoAllocMap
	ref702c36c0.offsetY, coffsetY_allocs = (C.int)(x.OffsetY), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetY_allocs)

	var cadvanceX_allocs *cgoAllocMap
	ref702c36c0.advanceX, cadvanceX_allocs = (C.int)(x.AdvanceX), cgoAllocsUnknown
	allocs702c36c0.Borrow(cadvanceX_allocs)

	var cimage_allocs *cgoAllocMap
	ref702c36c0.image, cimage_allocs = x.Image.PassValue()
	allocs702c36c0.Borrow(cimage_allocs)

	x.ref702c36c0 = ref702c36c0
	x.allocs702c36c0 = allocs702c36c0
	return ref702c36c0, allocs702c36c0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CharInfo) PassValue() (C.CharInfo, *cgoAllocMap) {
	if x.ref702c36c0 != nil {
		return *x.ref702c36c0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CharInfo) Deref() {
	if x.ref702c36c0 == nil {
		return
	}
	x.Value = (int32)(x.ref702c36c0.value)
	x.OffsetX = (int32)(x.ref702c36c0.offsetX)
	x.OffsetY = (int32)(x.ref702c36c0.offsetY)
	x.AdvanceX = (int32)(x.ref702c36c0.advanceX)
	x.Image = *NewImageRef(unsafe.Pointer(&x.ref702c36c0.image))
}

// allocFontMemory allocates memory for type C.Font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontValue = unsafe.Sizeof([1]C.Font{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSRectangle transforms a sliced Go data structure into plain C format.
func unpackSRectangle(x []Rectangle) (unpacked *C.Rectangle, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Rectangle) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRectangleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Rectangle)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Rectangle)(h.Data)
	return
}

// unpackSCharInfo transforms a sliced Go data structure into plain C format.
func unpackSCharInfo(x []CharInfo) (unpacked *C.CharInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.CharInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCharInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.CharInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.CharInfo)(h.Data)
	return
}

// packSRectangle reads sliced Go data structure out from plain C format.
func packSRectangle(v []Rectangle, ptr0 *C.Rectangle) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRectangleValue]C.Rectangle)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRectangleRef(unsafe.Pointer(&ptr1))
	}
}

// packSCharInfo reads sliced Go data structure out from plain C format.
func packSCharInfo(v []CharInfo, ptr0 *C.CharInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCharInfoValue]C.CharInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCharInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Font) Ref() *C.Font {
	if x == nil {
		return nil
	}
	return x.ref70a6a7ec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Font) Free() {
	if x != nil && x.allocs70a6a7ec != nil {
		x.allocs70a6a7ec.(*cgoAllocMap).Free()
		x.ref70a6a7ec = nil
	}
}

// NewFontRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFontRef(ref unsafe.Pointer) *Font {
	if ref == nil {
		return nil
	}
	obj := new(Font)
	obj.ref70a6a7ec = (*C.Font)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Font) PassRef() (*C.Font, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70a6a7ec != nil {
		return x.ref70a6a7ec, nil
	}
	mem70a6a7ec := allocFontMemory(1)
	ref70a6a7ec := (*C.Font)(mem70a6a7ec)
	allocs70a6a7ec := new(cgoAllocMap)
	allocs70a6a7ec.Add(mem70a6a7ec)

	var cbaseSize_allocs *cgoAllocMap
	ref70a6a7ec.baseSize, cbaseSize_allocs = (C.int)(x.BaseSize), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(cbaseSize_allocs)

	var ccharsCount_allocs *cgoAllocMap
	ref70a6a7ec.charsCount, ccharsCount_allocs = (C.int)(x.CharsCount), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(ccharsCount_allocs)

	var ctexture_allocs *cgoAllocMap
	ref70a6a7ec.texture, ctexture_allocs = x.Texture.PassValue()
	allocs70a6a7ec.Borrow(ctexture_allocs)

	var crecs_allocs *cgoAllocMap
	ref70a6a7ec.recs, crecs_allocs = unpackSRectangle(x.Recs)
	allocs70a6a7ec.Borrow(crecs_allocs)

	var cchars_allocs *cgoAllocMap
	ref70a6a7ec.chars, cchars_allocs = unpackSCharInfo(x.Chars)
	allocs70a6a7ec.Borrow(cchars_allocs)

	x.ref70a6a7ec = ref70a6a7ec
	x.allocs70a6a7ec = allocs70a6a7ec
	return ref70a6a7ec, allocs70a6a7ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Font) PassValue() (C.Font, *cgoAllocMap) {
	if x.ref70a6a7ec != nil {
		return *x.ref70a6a7ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Font) Deref() {
	if x.ref70a6a7ec == nil {
		return
	}
	x.BaseSize = (int32)(x.ref70a6a7ec.baseSize)
	x.CharsCount = (int32)(x.ref70a6a7ec.charsCount)
	x.Texture = *NewTexture2DRef(unsafe.Pointer(&x.ref70a6a7ec.texture))
	packSRectangle(x.Recs, x.ref70a6a7ec.recs)
	packSCharInfo(x.Chars, x.ref70a6a7ec.chars)
}

// allocCamera3DMemory allocates memory for type C.Camera3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCamera3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCamera3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCamera3DValue = unsafe.Sizeof([1]C.Camera3D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Camera3D) Ref() *C.Camera3D {
	if x == nil {
		return nil
	}
	return x.ref7b09036
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Camera3D) Free() {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
	}
}

// NewCamera3DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCamera3DRef(ref unsafe.Pointer) *Camera3D {
	if ref == nil {
		return nil
	}
	obj := new(Camera3D)
	obj.ref7b09036 = (*C.Camera3D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Camera3D) PassRef() (*C.Camera3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b09036 != nil {
		return x.ref7b09036, nil
	}
	mem7b09036 := allocCamera3DMemory(1)
	ref7b09036 := (*C.Camera3D)(mem7b09036)
	allocs7b09036 := new(cgoAllocMap)
	allocs7b09036.Add(mem7b09036)

	var cposition_allocs *cgoAllocMap
	ref7b09036.position, cposition_allocs = x.Position.PassValue()
	allocs7b09036.Borrow(cposition_allocs)

	var ctarget_allocs *cgoAllocMap
	ref7b09036.target, ctarget_allocs = x.Target.PassValue()
	allocs7b09036.Borrow(ctarget_allocs)

	var cup_allocs *cgoAllocMap
	ref7b09036.up, cup_allocs = x.Up.PassValue()
	allocs7b09036.Borrow(cup_allocs)

	var cfovy_allocs *cgoAllocMap
	ref7b09036.fovy, cfovy_allocs = (C.float)(x.Fovy), cgoAllocsUnknown
	allocs7b09036.Borrow(cfovy_allocs)

	var c_type_allocs *cgoAllocMap
	ref7b09036._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocs7b09036.Borrow(c_type_allocs)

	x.ref7b09036 = ref7b09036
	x.allocs7b09036 = allocs7b09036
	return ref7b09036, allocs7b09036

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Camera3D) PassValue() (C.Camera3D, *cgoAllocMap) {
	if x.ref7b09036 != nil {
		return *x.ref7b09036, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Camera3D) Deref() {
	if x.ref7b09036 == nil {
		return
	}
	x.Position = *NewVector3Ref(unsafe.Pointer(&x.ref7b09036.position))
	x.Target = *NewVector3Ref(unsafe.Pointer(&x.ref7b09036.target))
	x.Up = *NewVector3Ref(unsafe.Pointer(&x.ref7b09036.up))
	x.Fovy = (float32)(x.ref7b09036.fovy)
	x.Type = (int32)(x.ref7b09036._type)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Camera) Ref() *C.Camera3D {
	if x == nil {
		return nil
	}
	return x.ref7b09036
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Camera) Free() {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
	}
}

// NewCameraRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCameraRef(ref unsafe.Pointer) *Camera {
	if ref == nil {
		return nil
	}
	obj := new(Camera)
	obj.ref7b09036 = (*C.Camera3D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Camera) PassRef() (*C.Camera3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b09036 != nil {
		return x.ref7b09036, nil
	}
	mem7b09036 := allocCamera3DMemory(1)
	ref7b09036 := (*C.Camera3D)(mem7b09036)
	allocs7b09036 := new(cgoAllocMap)
	allocs7b09036.Add(mem7b09036)

	var cposition_allocs *cgoAllocMap
	ref7b09036.position, cposition_allocs = x.Position.PassValue()
	allocs7b09036.Borrow(cposition_allocs)

	var ctarget_allocs *cgoAllocMap
	ref7b09036.target, ctarget_allocs = x.Target.PassValue()
	allocs7b09036.Borrow(ctarget_allocs)

	var cup_allocs *cgoAllocMap
	ref7b09036.up, cup_allocs = x.Up.PassValue()
	allocs7b09036.Borrow(cup_allocs)

	var cfovy_allocs *cgoAllocMap
	ref7b09036.fovy, cfovy_allocs = (C.float)(x.Fovy), cgoAllocsUnknown
	allocs7b09036.Borrow(cfovy_allocs)

	var c_type_allocs *cgoAllocMap
	ref7b09036._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocs7b09036.Borrow(c_type_allocs)

	x.ref7b09036 = ref7b09036
	x.allocs7b09036 = allocs7b09036
	return ref7b09036, allocs7b09036

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Camera) PassValue() (C.Camera3D, *cgoAllocMap) {
	if x.ref7b09036 != nil {
		return *x.ref7b09036, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Camera) Deref() {
	if x.ref7b09036 == nil {
		return
	}
	x.Position = *NewVector3Ref(unsafe.Pointer(&x.ref7b09036.position))
	x.Target = *NewVector3Ref(unsafe.Pointer(&x.ref7b09036.target))
	x.Up = *NewVector3Ref(unsafe.Pointer(&x.ref7b09036.up))
	x.Fovy = (float32)(x.ref7b09036.fovy)
	x.Type = (int32)(x.ref7b09036._type)
}

// allocCamera2DMemory allocates memory for type C.Camera2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCamera2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCamera2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCamera2DValue = unsafe.Sizeof([1]C.Camera2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Camera2D) Ref() *C.Camera2D {
	if x == nil {
		return nil
	}
	return x.ref1eaba177
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Camera2D) Free() {
	if x != nil && x.allocs1eaba177 != nil {
		x.allocs1eaba177.(*cgoAllocMap).Free()
		x.ref1eaba177 = nil
	}
}

// NewCamera2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCamera2DRef(ref unsafe.Pointer) *Camera2D {
	if ref == nil {
		return nil
	}
	obj := new(Camera2D)
	obj.ref1eaba177 = (*C.Camera2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Camera2D) PassRef() (*C.Camera2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1eaba177 != nil {
		return x.ref1eaba177, nil
	}
	mem1eaba177 := allocCamera2DMemory(1)
	ref1eaba177 := (*C.Camera2D)(mem1eaba177)
	allocs1eaba177 := new(cgoAllocMap)
	allocs1eaba177.Add(mem1eaba177)

	var coffset_allocs *cgoAllocMap
	ref1eaba177.offset, coffset_allocs = x.Offset.PassValue()
	allocs1eaba177.Borrow(coffset_allocs)

	var ctarget_allocs *cgoAllocMap
	ref1eaba177.target, ctarget_allocs = x.Target.PassValue()
	allocs1eaba177.Borrow(ctarget_allocs)

	var crotation_allocs *cgoAllocMap
	ref1eaba177.rotation, crotation_allocs = (C.float)(x.Rotation), cgoAllocsUnknown
	allocs1eaba177.Borrow(crotation_allocs)

	var czoom_allocs *cgoAllocMap
	ref1eaba177.zoom, czoom_allocs = (C.float)(x.Zoom), cgoAllocsUnknown
	allocs1eaba177.Borrow(czoom_allocs)

	x.ref1eaba177 = ref1eaba177
	x.allocs1eaba177 = allocs1eaba177
	return ref1eaba177, allocs1eaba177

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Camera2D) PassValue() (C.Camera2D, *cgoAllocMap) {
	if x.ref1eaba177 != nil {
		return *x.ref1eaba177, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Camera2D) Deref() {
	if x.ref1eaba177 == nil {
		return
	}
	x.Offset = *NewVector2Ref(unsafe.Pointer(&x.ref1eaba177.offset))
	x.Target = *NewVector2Ref(unsafe.Pointer(&x.ref1eaba177.target))
	x.Rotation = (float32)(x.ref1eaba177.rotation)
	x.Zoom = (float32)(x.ref1eaba177.zoom)
}

// allocMeshMemory allocates memory for type C.Mesh in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMeshMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMeshValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMeshValue = unsafe.Sizeof([1]C.Mesh{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Mesh) Ref() *C.Mesh {
	if x == nil {
		return nil
	}
	return x.ref415d9568
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Mesh) Free() {
	if x != nil && x.allocs415d9568 != nil {
		x.allocs415d9568.(*cgoAllocMap).Free()
		x.ref415d9568 = nil
	}
}

// NewMeshRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMeshRef(ref unsafe.Pointer) *Mesh {
	if ref == nil {
		return nil
	}
	obj := new(Mesh)
	obj.ref415d9568 = (*C.Mesh)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Mesh) PassRef() (*C.Mesh, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref415d9568 != nil {
		return x.ref415d9568, nil
	}
	mem415d9568 := allocMeshMemory(1)
	ref415d9568 := (*C.Mesh)(mem415d9568)
	allocs415d9568 := new(cgoAllocMap)
	allocs415d9568.Add(mem415d9568)

	var cvertexCount_allocs *cgoAllocMap
	ref415d9568.vertexCount, cvertexCount_allocs = (C.int)(x.VertexCount), cgoAllocsUnknown
	allocs415d9568.Borrow(cvertexCount_allocs)

	var ctriangleCount_allocs *cgoAllocMap
	ref415d9568.triangleCount, ctriangleCount_allocs = (C.int)(x.TriangleCount), cgoAllocsUnknown
	allocs415d9568.Borrow(ctriangleCount_allocs)

	var cvertices_allocs *cgoAllocMap
	ref415d9568.vertices, cvertices_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Vertices)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cvertices_allocs)

	var ctexcoords_allocs *cgoAllocMap
	ref415d9568.texcoords, ctexcoords_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Texcoords)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(ctexcoords_allocs)

	var ctexcoords2_allocs *cgoAllocMap
	ref415d9568.texcoords2, ctexcoords2_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Texcoords2)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(ctexcoords2_allocs)

	var cnormals_allocs *cgoAllocMap
	ref415d9568.normals, cnormals_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Normals)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cnormals_allocs)

	var ctangents_allocs *cgoAllocMap
	ref415d9568.tangents, ctangents_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Tangents)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(ctangents_allocs)

	var ccolors_allocs *cgoAllocMap
	ref415d9568.colors, ccolors_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Colors)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(ccolors_allocs)

	var cindices_allocs *cgoAllocMap
	ref415d9568.indices, cindices_allocs = (*C.ushort)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Indices)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cindices_allocs)

	var canimVertices_allocs *cgoAllocMap
	ref415d9568.animVertices, canimVertices_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.AnimVertices)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(canimVertices_allocs)

	var canimNormals_allocs *cgoAllocMap
	ref415d9568.animNormals, canimNormals_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.AnimNormals)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(canimNormals_allocs)

	var cboneIds_allocs *cgoAllocMap
	ref415d9568.boneIds, cboneIds_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.BoneIds)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cboneIds_allocs)

	var cboneWeights_allocs *cgoAllocMap
	ref415d9568.boneWeights, cboneWeights_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.BoneWeights)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cboneWeights_allocs)

	var cvaoId_allocs *cgoAllocMap
	ref415d9568.vaoId, cvaoId_allocs = (C.uint)(x.VaoId), cgoAllocsUnknown
	allocs415d9568.Borrow(cvaoId_allocs)

	var cvboId_allocs *cgoAllocMap
	ref415d9568.vboId, cvboId_allocs = (*C.uint)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.VboId)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cvboId_allocs)

	x.ref415d9568 = ref415d9568
	x.allocs415d9568 = allocs415d9568
	return ref415d9568, allocs415d9568

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Mesh) PassValue() (C.Mesh, *cgoAllocMap) {
	if x.ref415d9568 != nil {
		return *x.ref415d9568, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Mesh) Deref() {
	if x.ref415d9568 == nil {
		return
	}
	x.VertexCount = (int32)(x.ref415d9568.vertexCount)
	x.TriangleCount = (int32)(x.ref415d9568.triangleCount)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Vertices))
	hxfc4425b.Data = unsafe.Pointer(x.ref415d9568.vertices)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.Texcoords))
	hxf95e7c8.Data = unsafe.Pointer(x.ref415d9568.texcoords)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.Texcoords2))
	hxff2234b.Data = unsafe.Pointer(x.ref415d9568.texcoords2)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.Normals))
	hxff73280.Data = unsafe.Pointer(x.ref415d9568.normals)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.Tangents))
	hxfa9955c.Data = unsafe.Pointer(x.ref415d9568.tangents)
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.Colors))
	hxfa3f05c.Data = unsafe.Pointer(x.ref415d9568.colors)
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ?

	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x.Indices))
	hxf0d18b7.Data = unsafe.Pointer(x.ref415d9568.indices)
	hxf0d18b7.Cap = 0x7fffffff
	// hxf0d18b7.Len = ?

	hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&x.AnimVertices))
	hxf2fab0d.Data = unsafe.Pointer(x.ref415d9568.animVertices)
	hxf2fab0d.Cap = 0x7fffffff
	// hxf2fab0d.Len = ?

	hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&x.AnimNormals))
	hxf69fe70.Data = unsafe.Pointer(x.ref415d9568.animNormals)
	hxf69fe70.Cap = 0x7fffffff
	// hxf69fe70.Len = ?

	hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&x.BoneIds))
	hxf65bf54.Data = unsafe.Pointer(x.ref415d9568.boneIds)
	hxf65bf54.Cap = 0x7fffffff
	// hxf65bf54.Len = ?

	hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&x.BoneWeights))
	hxf3b8dbd.Data = unsafe.Pointer(x.ref415d9568.boneWeights)
	hxf3b8dbd.Cap = 0x7fffffff
	// hxf3b8dbd.Len = ?

	x.VaoId = (uint32)(x.ref415d9568.vaoId)
	hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&x.VboId))
	hxf7a6dff.Data = unsafe.Pointer(x.ref415d9568.vboId)
	hxf7a6dff.Cap = 0x7fffffff
	// hxf7a6dff.Len = ?

}

// allocShaderMemory allocates memory for type C.Shader in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderValue = unsafe.Sizeof([1]C.Shader{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Shader) Ref() *C.Shader {
	if x == nil {
		return nil
	}
	return x.reff85f9b1e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Shader) Free() {
	if x != nil && x.allocsf85f9b1e != nil {
		x.allocsf85f9b1e.(*cgoAllocMap).Free()
		x.reff85f9b1e = nil
	}
}

// NewShaderRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderRef(ref unsafe.Pointer) *Shader {
	if ref == nil {
		return nil
	}
	obj := new(Shader)
	obj.reff85f9b1e = (*C.Shader)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Shader) PassRef() (*C.Shader, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff85f9b1e != nil {
		return x.reff85f9b1e, nil
	}
	memf85f9b1e := allocShaderMemory(1)
	reff85f9b1e := (*C.Shader)(memf85f9b1e)
	allocsf85f9b1e := new(cgoAllocMap)
	allocsf85f9b1e.Add(memf85f9b1e)

	var cid_allocs *cgoAllocMap
	reff85f9b1e.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocsf85f9b1e.Borrow(cid_allocs)

	var clocs_allocs *cgoAllocMap
	reff85f9b1e.locs, clocs_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Locs)).Data)), cgoAllocsUnknown
	allocsf85f9b1e.Borrow(clocs_allocs)

	x.reff85f9b1e = reff85f9b1e
	x.allocsf85f9b1e = allocsf85f9b1e
	return reff85f9b1e, allocsf85f9b1e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Shader) PassValue() (C.Shader, *cgoAllocMap) {
	if x.reff85f9b1e != nil {
		return *x.reff85f9b1e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Shader) Deref() {
	if x.reff85f9b1e == nil {
		return
	}
	x.Id = (uint32)(x.reff85f9b1e.id)
	hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&x.Locs))
	hxfe48d67.Data = unsafe.Pointer(x.reff85f9b1e.locs)
	hxfe48d67.Cap = 0x7fffffff
	// hxfe48d67.Len = ?

}

// allocMaterialMapMemory allocates memory for type C.MaterialMap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMaterialMapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMaterialMapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMaterialMapValue = unsafe.Sizeof([1]C.MaterialMap{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MaterialMap) Ref() *C.MaterialMap {
	if x == nil {
		return nil
	}
	return x.refa8350ad3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MaterialMap) Free() {
	if x != nil && x.allocsa8350ad3 != nil {
		x.allocsa8350ad3.(*cgoAllocMap).Free()
		x.refa8350ad3 = nil
	}
}

// NewMaterialMapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMaterialMapRef(ref unsafe.Pointer) *MaterialMap {
	if ref == nil {
		return nil
	}
	obj := new(MaterialMap)
	obj.refa8350ad3 = (*C.MaterialMap)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MaterialMap) PassRef() (*C.MaterialMap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8350ad3 != nil {
		return x.refa8350ad3, nil
	}
	mema8350ad3 := allocMaterialMapMemory(1)
	refa8350ad3 := (*C.MaterialMap)(mema8350ad3)
	allocsa8350ad3 := new(cgoAllocMap)
	allocsa8350ad3.Add(mema8350ad3)

	var ctexture_allocs *cgoAllocMap
	refa8350ad3.texture, ctexture_allocs = x.Texture.PassValue()
	allocsa8350ad3.Borrow(ctexture_allocs)

	var ccolor_allocs *cgoAllocMap
	refa8350ad3.color, ccolor_allocs = x.Color.PassValue()
	allocsa8350ad3.Borrow(ccolor_allocs)

	var cvalue_allocs *cgoAllocMap
	refa8350ad3.value, cvalue_allocs = (C.float)(x.Value), cgoAllocsUnknown
	allocsa8350ad3.Borrow(cvalue_allocs)

	x.refa8350ad3 = refa8350ad3
	x.allocsa8350ad3 = allocsa8350ad3
	return refa8350ad3, allocsa8350ad3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MaterialMap) PassValue() (C.MaterialMap, *cgoAllocMap) {
	if x.refa8350ad3 != nil {
		return *x.refa8350ad3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MaterialMap) Deref() {
	if x.refa8350ad3 == nil {
		return
	}
	x.Texture = *NewTexture2DRef(unsafe.Pointer(&x.refa8350ad3.texture))
	x.Color = *NewColorRef(unsafe.Pointer(&x.refa8350ad3.color))
	x.Value = (float32)(x.refa8350ad3.value)
}

// allocMaterialMemory allocates memory for type C.Material in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMaterialMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMaterialValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMaterialValue = unsafe.Sizeof([1]C.Material{})

// unpackSMaterialMap transforms a sliced Go data structure into plain C format.
func unpackSMaterialMap(x []MaterialMap) (unpacked *C.MaterialMap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.MaterialMap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMaterialMapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.MaterialMap)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.MaterialMap)(h.Data)
	return
}

// packSMaterialMap reads sliced Go data structure out from plain C format.
func packSMaterialMap(v []MaterialMap, ptr0 *C.MaterialMap) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMaterialMapValue]C.MaterialMap)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMaterialMapRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Material) Ref() *C.Material {
	if x == nil {
		return nil
	}
	return x.ref85c817c3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Material) Free() {
	if x != nil && x.allocs85c817c3 != nil {
		x.allocs85c817c3.(*cgoAllocMap).Free()
		x.ref85c817c3 = nil
	}
}

// NewMaterialRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMaterialRef(ref unsafe.Pointer) *Material {
	if ref == nil {
		return nil
	}
	obj := new(Material)
	obj.ref85c817c3 = (*C.Material)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Material) PassRef() (*C.Material, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85c817c3 != nil {
		return x.ref85c817c3, nil
	}
	mem85c817c3 := allocMaterialMemory(1)
	ref85c817c3 := (*C.Material)(mem85c817c3)
	allocs85c817c3 := new(cgoAllocMap)
	allocs85c817c3.Add(mem85c817c3)

	var cshader_allocs *cgoAllocMap
	ref85c817c3.shader, cshader_allocs = x.Shader.PassValue()
	allocs85c817c3.Borrow(cshader_allocs)

	var cmaps_allocs *cgoAllocMap
	ref85c817c3.maps, cmaps_allocs = unpackSMaterialMap(x.Maps)
	allocs85c817c3.Borrow(cmaps_allocs)

	var cparams_allocs *cgoAllocMap
	ref85c817c3.params, cparams_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Params)).Data)), cgoAllocsUnknown
	allocs85c817c3.Borrow(cparams_allocs)

	x.ref85c817c3 = ref85c817c3
	x.allocs85c817c3 = allocs85c817c3
	return ref85c817c3, allocs85c817c3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Material) PassValue() (C.Material, *cgoAllocMap) {
	if x.ref85c817c3 != nil {
		return *x.ref85c817c3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Material) Deref() {
	if x.ref85c817c3 == nil {
		return
	}
	x.Shader = *NewShaderRef(unsafe.Pointer(&x.ref85c817c3.shader))
	packSMaterialMap(x.Maps, x.ref85c817c3.maps)
	hxf4171bf := (*sliceHeader)(unsafe.Pointer(&x.Params))
	hxf4171bf.Data = unsafe.Pointer(x.ref85c817c3.params)
	hxf4171bf.Cap = 0x7fffffff
	// hxf4171bf.Len = ?

}

// allocTransformMemory allocates memory for type C.Transform in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTransformMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTransformValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTransformValue = unsafe.Sizeof([1]C.Transform{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Transform) Ref() *C.Transform {
	if x == nil {
		return nil
	}
	return x.reff543030e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Transform) Free() {
	if x != nil && x.allocsf543030e != nil {
		x.allocsf543030e.(*cgoAllocMap).Free()
		x.reff543030e = nil
	}
}

// NewTransformRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTransformRef(ref unsafe.Pointer) *Transform {
	if ref == nil {
		return nil
	}
	obj := new(Transform)
	obj.reff543030e = (*C.Transform)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Transform) PassRef() (*C.Transform, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff543030e != nil {
		return x.reff543030e, nil
	}
	memf543030e := allocTransformMemory(1)
	reff543030e := (*C.Transform)(memf543030e)
	allocsf543030e := new(cgoAllocMap)
	allocsf543030e.Add(memf543030e)

	var ctranslation_allocs *cgoAllocMap
	reff543030e.translation, ctranslation_allocs = x.Translation.PassValue()
	allocsf543030e.Borrow(ctranslation_allocs)

	var crotation_allocs *cgoAllocMap
	reff543030e.rotation, crotation_allocs = x.Rotation.PassValue()
	allocsf543030e.Borrow(crotation_allocs)

	var cscale_allocs *cgoAllocMap
	reff543030e.scale, cscale_allocs = x.Scale.PassValue()
	allocsf543030e.Borrow(cscale_allocs)

	x.reff543030e = reff543030e
	x.allocsf543030e = allocsf543030e
	return reff543030e, allocsf543030e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Transform) PassValue() (C.Transform, *cgoAllocMap) {
	if x.reff543030e != nil {
		return *x.reff543030e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Transform) Deref() {
	if x.reff543030e == nil {
		return
	}
	x.Translation = *NewVector3Ref(unsafe.Pointer(&x.reff543030e.translation))
	x.Rotation = *NewQuaternionRef(unsafe.Pointer(&x.reff543030e.rotation))
	x.Scale = *NewVector3Ref(unsafe.Pointer(&x.reff543030e.scale))
}

// allocBoneInfoMemory allocates memory for type C.BoneInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBoneInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBoneInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBoneInfoValue = unsafe.Sizeof([1]C.BoneInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BoneInfo) Ref() *C.BoneInfo {
	if x == nil {
		return nil
	}
	return x.ref5ab7f197
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BoneInfo) Free() {
	if x != nil && x.allocs5ab7f197 != nil {
		x.allocs5ab7f197.(*cgoAllocMap).Free()
		x.ref5ab7f197 = nil
	}
}

// NewBoneInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBoneInfoRef(ref unsafe.Pointer) *BoneInfo {
	if ref == nil {
		return nil
	}
	obj := new(BoneInfo)
	obj.ref5ab7f197 = (*C.BoneInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BoneInfo) PassRef() (*C.BoneInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ab7f197 != nil {
		return x.ref5ab7f197, nil
	}
	mem5ab7f197 := allocBoneInfoMemory(1)
	ref5ab7f197 := (*C.BoneInfo)(mem5ab7f197)
	allocs5ab7f197 := new(cgoAllocMap)
	allocs5ab7f197.Add(mem5ab7f197)

	var cname_allocs *cgoAllocMap
	ref5ab7f197.name, cname_allocs = *(*[32]C.char)(unsafe.Pointer(&x.Name)), cgoAllocsUnknown
	allocs5ab7f197.Borrow(cname_allocs)

	var cparent_allocs *cgoAllocMap
	ref5ab7f197.parent, cparent_allocs = (C.int)(x.Parent), cgoAllocsUnknown
	allocs5ab7f197.Borrow(cparent_allocs)

	x.ref5ab7f197 = ref5ab7f197
	x.allocs5ab7f197 = allocs5ab7f197
	return ref5ab7f197, allocs5ab7f197

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BoneInfo) PassValue() (C.BoneInfo, *cgoAllocMap) {
	if x.ref5ab7f197 != nil {
		return *x.ref5ab7f197, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BoneInfo) Deref() {
	if x.ref5ab7f197 == nil {
		return
	}
	x.Name = *(*[32]byte)(unsafe.Pointer(&x.ref5ab7f197.name))
	x.Parent = (int32)(x.ref5ab7f197.parent)
}

// allocModelMemory allocates memory for type C.Model in C.
// The caller is responsible for freeing the this memory via C.free.
func allocModelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfModelValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfModelValue = unsafe.Sizeof([1]C.Model{})

// unpackSMesh transforms a sliced Go data structure into plain C format.
func unpackSMesh(x []Mesh) (unpacked *C.Mesh, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Mesh) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMeshMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Mesh)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Mesh)(h.Data)
	return
}

// unpackSMaterial transforms a sliced Go data structure into plain C format.
func unpackSMaterial(x []Material) (unpacked *C.Material, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Material) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMaterialMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Material)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Material)(h.Data)
	return
}

// unpackSBoneInfo transforms a sliced Go data structure into plain C format.
func unpackSBoneInfo(x []BoneInfo) (unpacked *C.BoneInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.BoneInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBoneInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.BoneInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.BoneInfo)(h.Data)
	return
}

// unpackSTransform transforms a sliced Go data structure into plain C format.
func unpackSTransform(x []Transform) (unpacked *C.Transform, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Transform) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocTransformMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Transform)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Transform)(h.Data)
	return
}

// packSMesh reads sliced Go data structure out from plain C format.
func packSMesh(v []Mesh, ptr0 *C.Mesh) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMeshValue]C.Mesh)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMeshRef(unsafe.Pointer(&ptr1))
	}
}

// packSMaterial reads sliced Go data structure out from plain C format.
func packSMaterial(v []Material, ptr0 *C.Material) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMaterialValue]C.Material)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMaterialRef(unsafe.Pointer(&ptr1))
	}
}

// packSBoneInfo reads sliced Go data structure out from plain C format.
func packSBoneInfo(v []BoneInfo, ptr0 *C.BoneInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBoneInfoValue]C.BoneInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBoneInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSTransform reads sliced Go data structure out from plain C format.
func packSTransform(v []Transform, ptr0 *C.Transform) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTransformValue]C.Transform)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTransformRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Model) Ref() *C.Model {
	if x == nil {
		return nil
	}
	return x.ref16545ddd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Model) Free() {
	if x != nil && x.allocs16545ddd != nil {
		x.allocs16545ddd.(*cgoAllocMap).Free()
		x.ref16545ddd = nil
	}
}

// NewModelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewModelRef(ref unsafe.Pointer) *Model {
	if ref == nil {
		return nil
	}
	obj := new(Model)
	obj.ref16545ddd = (*C.Model)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Model) PassRef() (*C.Model, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref16545ddd != nil {
		return x.ref16545ddd, nil
	}
	mem16545ddd := allocModelMemory(1)
	ref16545ddd := (*C.Model)(mem16545ddd)
	allocs16545ddd := new(cgoAllocMap)
	allocs16545ddd.Add(mem16545ddd)

	var ctransform_allocs *cgoAllocMap
	ref16545ddd.transform, ctransform_allocs = x.Transform.PassValue()
	allocs16545ddd.Borrow(ctransform_allocs)

	var cmeshCount_allocs *cgoAllocMap
	ref16545ddd.meshCount, cmeshCount_allocs = (C.int)(x.MeshCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmeshCount_allocs)

	var cmeshes_allocs *cgoAllocMap
	ref16545ddd.meshes, cmeshes_allocs = unpackSMesh(x.Meshes)
	allocs16545ddd.Borrow(cmeshes_allocs)

	var cmaterialCount_allocs *cgoAllocMap
	ref16545ddd.materialCount, cmaterialCount_allocs = (C.int)(x.MaterialCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmaterialCount_allocs)

	var cmaterials_allocs *cgoAllocMap
	ref16545ddd.materials, cmaterials_allocs = unpackSMaterial(x.Materials)
	allocs16545ddd.Borrow(cmaterials_allocs)

	var cmeshMaterial_allocs *cgoAllocMap
	ref16545ddd.meshMaterial, cmeshMaterial_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.MeshMaterial)).Data)), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmeshMaterial_allocs)

	var cboneCount_allocs *cgoAllocMap
	ref16545ddd.boneCount, cboneCount_allocs = (C.int)(x.BoneCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cboneCount_allocs)

	var cbones_allocs *cgoAllocMap
	ref16545ddd.bones, cbones_allocs = unpackSBoneInfo(x.Bones)
	allocs16545ddd.Borrow(cbones_allocs)

	var cbindPose_allocs *cgoAllocMap
	ref16545ddd.bindPose, cbindPose_allocs = unpackSTransform(x.BindPose)
	allocs16545ddd.Borrow(cbindPose_allocs)

	x.ref16545ddd = ref16545ddd
	x.allocs16545ddd = allocs16545ddd
	return ref16545ddd, allocs16545ddd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Model) PassValue() (C.Model, *cgoAllocMap) {
	if x.ref16545ddd != nil {
		return *x.ref16545ddd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Model) Deref() {
	if x.ref16545ddd == nil {
		return
	}
	x.Transform = *NewMatrixRef(unsafe.Pointer(&x.ref16545ddd.transform))
	x.MeshCount = (int32)(x.ref16545ddd.meshCount)
	packSMesh(x.Meshes, x.ref16545ddd.meshes)
	x.MaterialCount = (int32)(x.ref16545ddd.materialCount)
	packSMaterial(x.Materials, x.ref16545ddd.materials)
	hxf058b18 := (*sliceHeader)(unsafe.Pointer(&x.MeshMaterial))
	hxf058b18.Data = unsafe.Pointer(x.ref16545ddd.meshMaterial)
	hxf058b18.Cap = 0x7fffffff
	// hxf058b18.Len = ?

	x.BoneCount = (int32)(x.ref16545ddd.boneCount)
	packSBoneInfo(x.Bones, x.ref16545ddd.bones)
	packSTransform(x.BindPose, x.ref16545ddd.bindPose)
}

// allocModelAnimationMemory allocates memory for type C.ModelAnimation in C.
// The caller is responsible for freeing the this memory via C.free.
func allocModelAnimationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfModelAnimationValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfModelAnimationValue = unsafe.Sizeof([1]C.ModelAnimation{})

// allocPTransformMemory allocates memory for type *C.Transform in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTransformMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTransformValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPTransformValue = unsafe.Sizeof([1]*C.Transform{})

// unpackSSTransform transforms a sliced Go data structure into plain C format.
func unpackSSTransform(x [][]Transform) (unpacked **C.Transform, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.Transform) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPTransformMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.Transform)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTransformMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.Transform)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.Transform)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.Transform)(h.Data)
	return
}

// packSSTransform reads sliced Go data structure out from plain C format.
func packSSTransform(v [][]Transform, ptr0 **C.Transform) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.Transform)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTransformValue]C.Transform)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTransformRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ModelAnimation) Ref() *C.ModelAnimation {
	if x == nil {
		return nil
	}
	return x.ref26dd6a24
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ModelAnimation) Free() {
	if x != nil && x.allocs26dd6a24 != nil {
		x.allocs26dd6a24.(*cgoAllocMap).Free()
		x.ref26dd6a24 = nil
	}
}

// NewModelAnimationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewModelAnimationRef(ref unsafe.Pointer) *ModelAnimation {
	if ref == nil {
		return nil
	}
	obj := new(ModelAnimation)
	obj.ref26dd6a24 = (*C.ModelAnimation)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ModelAnimation) PassRef() (*C.ModelAnimation, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref26dd6a24 != nil {
		return x.ref26dd6a24, nil
	}
	mem26dd6a24 := allocModelAnimationMemory(1)
	ref26dd6a24 := (*C.ModelAnimation)(mem26dd6a24)
	allocs26dd6a24 := new(cgoAllocMap)
	allocs26dd6a24.Add(mem26dd6a24)

	var cboneCount_allocs *cgoAllocMap
	ref26dd6a24.boneCount, cboneCount_allocs = (C.int)(x.BoneCount), cgoAllocsUnknown
	allocs26dd6a24.Borrow(cboneCount_allocs)

	var cbones_allocs *cgoAllocMap
	ref26dd6a24.bones, cbones_allocs = unpackSBoneInfo(x.Bones)
	allocs26dd6a24.Borrow(cbones_allocs)

	var cframeCount_allocs *cgoAllocMap
	ref26dd6a24.frameCount, cframeCount_allocs = (C.int)(x.FrameCount), cgoAllocsUnknown
	allocs26dd6a24.Borrow(cframeCount_allocs)

	var cframePoses_allocs *cgoAllocMap
	ref26dd6a24.framePoses, cframePoses_allocs = unpackSSTransform(x.FramePoses)
	allocs26dd6a24.Borrow(cframePoses_allocs)

	x.ref26dd6a24 = ref26dd6a24
	x.allocs26dd6a24 = allocs26dd6a24
	return ref26dd6a24, allocs26dd6a24

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ModelAnimation) PassValue() (C.ModelAnimation, *cgoAllocMap) {
	if x.ref26dd6a24 != nil {
		return *x.ref26dd6a24, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ModelAnimation) Deref() {
	if x.ref26dd6a24 == nil {
		return
	}
	x.BoneCount = (int32)(x.ref26dd6a24.boneCount)
	packSBoneInfo(x.Bones, x.ref26dd6a24.bones)
	x.FrameCount = (int32)(x.ref26dd6a24.frameCount)
	packSSTransform(x.FramePoses, x.ref26dd6a24.framePoses)
}

// allocRayMemory allocates memory for type C.Ray in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRayValue = unsafe.Sizeof([1]C.Ray{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Ray) Ref() *C.Ray {
	if x == nil {
		return nil
	}
	return x.refc546b0b2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Ray) Free() {
	if x != nil && x.allocsc546b0b2 != nil {
		x.allocsc546b0b2.(*cgoAllocMap).Free()
		x.refc546b0b2 = nil
	}
}

// NewRayRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRayRef(ref unsafe.Pointer) *Ray {
	if ref == nil {
		return nil
	}
	obj := new(Ray)
	obj.refc546b0b2 = (*C.Ray)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Ray) PassRef() (*C.Ray, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc546b0b2 != nil {
		return x.refc546b0b2, nil
	}
	memc546b0b2 := allocRayMemory(1)
	refc546b0b2 := (*C.Ray)(memc546b0b2)
	allocsc546b0b2 := new(cgoAllocMap)
	allocsc546b0b2.Add(memc546b0b2)

	var cposition_allocs *cgoAllocMap
	refc546b0b2.position, cposition_allocs = x.Position.PassValue()
	allocsc546b0b2.Borrow(cposition_allocs)

	var cdirection_allocs *cgoAllocMap
	refc546b0b2.direction, cdirection_allocs = x.Direction.PassValue()
	allocsc546b0b2.Borrow(cdirection_allocs)

	x.refc546b0b2 = refc546b0b2
	x.allocsc546b0b2 = allocsc546b0b2
	return refc546b0b2, allocsc546b0b2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Ray) PassValue() (C.Ray, *cgoAllocMap) {
	if x.refc546b0b2 != nil {
		return *x.refc546b0b2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Ray) Deref() {
	if x.refc546b0b2 == nil {
		return
	}
	x.Position = *NewVector3Ref(unsafe.Pointer(&x.refc546b0b2.position))
	x.Direction = *NewVector3Ref(unsafe.Pointer(&x.refc546b0b2.direction))
}

// allocRayHitInfoMemory allocates memory for type C.RayHitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayHitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayHitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRayHitInfoValue = unsafe.Sizeof([1]C.RayHitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RayHitInfo) Ref() *C.RayHitInfo {
	if x == nil {
		return nil
	}
	return x.refb8de43a9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RayHitInfo) Free() {
	if x != nil && x.allocsb8de43a9 != nil {
		x.allocsb8de43a9.(*cgoAllocMap).Free()
		x.refb8de43a9 = nil
	}
}

// NewRayHitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRayHitInfoRef(ref unsafe.Pointer) *RayHitInfo {
	if ref == nil {
		return nil
	}
	obj := new(RayHitInfo)
	obj.refb8de43a9 = (*C.RayHitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RayHitInfo) PassRef() (*C.RayHitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8de43a9 != nil {
		return x.refb8de43a9, nil
	}
	memb8de43a9 := allocRayHitInfoMemory(1)
	refb8de43a9 := (*C.RayHitInfo)(memb8de43a9)
	allocsb8de43a9 := new(cgoAllocMap)
	allocsb8de43a9.Add(memb8de43a9)

	var chit_allocs *cgoAllocMap
	refb8de43a9.hit, chit_allocs = (C._Bool)(x.Hit), cgoAllocsUnknown
	allocsb8de43a9.Borrow(chit_allocs)

	var cdistance_allocs *cgoAllocMap
	refb8de43a9.distance, cdistance_allocs = (C.float)(x.Distance), cgoAllocsUnknown
	allocsb8de43a9.Borrow(cdistance_allocs)

	var cposition_allocs *cgoAllocMap
	refb8de43a9.position, cposition_allocs = x.Position.PassValue()
	allocsb8de43a9.Borrow(cposition_allocs)

	var cnormal_allocs *cgoAllocMap
	refb8de43a9.normal, cnormal_allocs = x.Normal.PassValue()
	allocsb8de43a9.Borrow(cnormal_allocs)

	x.refb8de43a9 = refb8de43a9
	x.allocsb8de43a9 = allocsb8de43a9
	return refb8de43a9, allocsb8de43a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RayHitInfo) PassValue() (C.RayHitInfo, *cgoAllocMap) {
	if x.refb8de43a9 != nil {
		return *x.refb8de43a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RayHitInfo) Deref() {
	if x.refb8de43a9 == nil {
		return
	}
	x.Hit = (bool)(x.refb8de43a9.hit)
	x.Distance = (float32)(x.refb8de43a9.distance)
	x.Position = *NewVector3Ref(unsafe.Pointer(&x.refb8de43a9.position))
	x.Normal = *NewVector3Ref(unsafe.Pointer(&x.refb8de43a9.normal))
}

// allocBoundingBoxMemory allocates memory for type C.BoundingBox in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBoundingBoxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBoundingBoxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBoundingBoxValue = unsafe.Sizeof([1]C.BoundingBox{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BoundingBox) Ref() *C.BoundingBox {
	if x == nil {
		return nil
	}
	return x.refa54e9d16
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BoundingBox) Free() {
	if x != nil && x.allocsa54e9d16 != nil {
		x.allocsa54e9d16.(*cgoAllocMap).Free()
		x.refa54e9d16 = nil
	}
}

// NewBoundingBoxRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBoundingBoxRef(ref unsafe.Pointer) *BoundingBox {
	if ref == nil {
		return nil
	}
	obj := new(BoundingBox)
	obj.refa54e9d16 = (*C.BoundingBox)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BoundingBox) PassRef() (*C.BoundingBox, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa54e9d16 != nil {
		return x.refa54e9d16, nil
	}
	mema54e9d16 := allocBoundingBoxMemory(1)
	refa54e9d16 := (*C.BoundingBox)(mema54e9d16)
	allocsa54e9d16 := new(cgoAllocMap)
	allocsa54e9d16.Add(mema54e9d16)

	var cmin_allocs *cgoAllocMap
	refa54e9d16.min, cmin_allocs = x.Min.PassValue()
	allocsa54e9d16.Borrow(cmin_allocs)

	var cmax_allocs *cgoAllocMap
	refa54e9d16.max, cmax_allocs = x.Max.PassValue()
	allocsa54e9d16.Borrow(cmax_allocs)

	x.refa54e9d16 = refa54e9d16
	x.allocsa54e9d16 = allocsa54e9d16
	return refa54e9d16, allocsa54e9d16

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BoundingBox) PassValue() (C.BoundingBox, *cgoAllocMap) {
	if x.refa54e9d16 != nil {
		return *x.refa54e9d16, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BoundingBox) Deref() {
	if x.refa54e9d16 == nil {
		return
	}
	x.Min = *NewVector3Ref(unsafe.Pointer(&x.refa54e9d16.min))
	x.Max = *NewVector3Ref(unsafe.Pointer(&x.refa54e9d16.max))
}

// allocWaveMemory allocates memory for type C.Wave in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWaveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWaveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWaveValue = unsafe.Sizeof([1]C.Wave{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Wave) Ref() *C.Wave {
	if x == nil {
		return nil
	}
	return x.ref7a3602b7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Wave) Free() {
	if x != nil && x.allocs7a3602b7 != nil {
		x.allocs7a3602b7.(*cgoAllocMap).Free()
		x.ref7a3602b7 = nil
	}
}

// NewWaveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWaveRef(ref unsafe.Pointer) *Wave {
	if ref == nil {
		return nil
	}
	obj := new(Wave)
	obj.ref7a3602b7 = (*C.Wave)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Wave) PassRef() (*C.Wave, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7a3602b7 != nil {
		return x.ref7a3602b7, nil
	}
	mem7a3602b7 := allocWaveMemory(1)
	ref7a3602b7 := (*C.Wave)(mem7a3602b7)
	allocs7a3602b7 := new(cgoAllocMap)
	allocs7a3602b7.Add(mem7a3602b7)

	var csampleCount_allocs *cgoAllocMap
	ref7a3602b7.sampleCount, csampleCount_allocs = (C.uint)(x.SampleCount), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleCount_allocs)

	var csampleRate_allocs *cgoAllocMap
	ref7a3602b7.sampleRate, csampleRate_allocs = (C.uint)(x.SampleRate), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleRate_allocs)

	var csampleSize_allocs *cgoAllocMap
	ref7a3602b7.sampleSize, csampleSize_allocs = (C.uint)(x.SampleSize), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleSize_allocs)

	var cchannels_allocs *cgoAllocMap
	ref7a3602b7.channels, cchannels_allocs = (C.uint)(x.Channels), cgoAllocsUnknown
	allocs7a3602b7.Borrow(cchannels_allocs)

	var cdata_allocs *cgoAllocMap
	ref7a3602b7.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocs7a3602b7.Borrow(cdata_allocs)

	x.ref7a3602b7 = ref7a3602b7
	x.allocs7a3602b7 = allocs7a3602b7
	return ref7a3602b7, allocs7a3602b7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Wave) PassValue() (C.Wave, *cgoAllocMap) {
	if x.ref7a3602b7 != nil {
		return *x.ref7a3602b7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Wave) Deref() {
	if x.ref7a3602b7 == nil {
		return
	}
	x.SampleCount = (uint32)(x.ref7a3602b7.sampleCount)
	x.SampleRate = (uint32)(x.ref7a3602b7.sampleRate)
	x.SampleSize = (uint32)(x.ref7a3602b7.sampleSize)
	x.Channels = (uint32)(x.ref7a3602b7.channels)
	x.Data = (unsafe.Pointer)(unsafe.Pointer(x.ref7a3602b7.data))
}

// Ref returns a reference to C object as it is.
func (x *RAudioBuffer) Ref() *C.rAudioBuffer {
	if x == nil {
		return nil
	}
	return (*C.rAudioBuffer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *RAudioBuffer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRAudioBufferRef converts the C object reference into a raw struct reference without wrapping.
func NewRAudioBufferRef(ref unsafe.Pointer) *RAudioBuffer {
	return (*RAudioBuffer)(ref)
}

// NewRAudioBuffer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRAudioBuffer() *RAudioBuffer {
	return (*RAudioBuffer)(allocRAudioBufferMemory(1))
}

// allocRAudioBufferMemory allocates memory for type C.rAudioBuffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRAudioBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRAudioBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRAudioBufferValue = unsafe.Sizeof([1]C.rAudioBuffer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *RAudioBuffer) PassRef() *C.rAudioBuffer {
	if x == nil {
		x = (*RAudioBuffer)(allocRAudioBufferMemory(1))
	}
	return (*C.rAudioBuffer)(unsafe.Pointer(x))
}

// allocAudioStreamMemory allocates memory for type C.AudioStream in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioStreamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioStreamValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAudioStreamValue = unsafe.Sizeof([1]C.AudioStream{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AudioStream) Ref() *C.AudioStream {
	if x == nil {
		return nil
	}
	return x.ref997374a2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AudioStream) Free() {
	if x != nil && x.allocs997374a2 != nil {
		x.allocs997374a2.(*cgoAllocMap).Free()
		x.ref997374a2 = nil
	}
}

// NewAudioStreamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAudioStreamRef(ref unsafe.Pointer) *AudioStream {
	if ref == nil {
		return nil
	}
	obj := new(AudioStream)
	obj.ref997374a2 = (*C.AudioStream)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AudioStream) PassRef() (*C.AudioStream, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref997374a2 != nil {
		return x.ref997374a2, nil
	}
	mem997374a2 := allocAudioStreamMemory(1)
	ref997374a2 := (*C.AudioStream)(mem997374a2)
	allocs997374a2 := new(cgoAllocMap)
	allocs997374a2.Add(mem997374a2)

	var csampleRate_allocs *cgoAllocMap
	ref997374a2.sampleRate, csampleRate_allocs = (C.uint)(x.SampleRate), cgoAllocsUnknown
	allocs997374a2.Borrow(csampleRate_allocs)

	var csampleSize_allocs *cgoAllocMap
	ref997374a2.sampleSize, csampleSize_allocs = (C.uint)(x.SampleSize), cgoAllocsUnknown
	allocs997374a2.Borrow(csampleSize_allocs)

	var cchannels_allocs *cgoAllocMap
	ref997374a2.channels, cchannels_allocs = (C.uint)(x.Channels), cgoAllocsUnknown
	allocs997374a2.Borrow(cchannels_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref997374a2.buffer, cbuffer_allocs = (*C.rAudioBuffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Buffer)).Data)), cgoAllocsUnknown
	allocs997374a2.Borrow(cbuffer_allocs)

	x.ref997374a2 = ref997374a2
	x.allocs997374a2 = allocs997374a2
	return ref997374a2, allocs997374a2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AudioStream) PassValue() (C.AudioStream, *cgoAllocMap) {
	if x.ref997374a2 != nil {
		return *x.ref997374a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AudioStream) Deref() {
	if x.ref997374a2 == nil {
		return
	}
	x.SampleRate = (uint32)(x.ref997374a2.sampleRate)
	x.SampleSize = (uint32)(x.ref997374a2.sampleSize)
	x.Channels = (uint32)(x.ref997374a2.channels)
	hxff6bc57 := (*sliceHeader)(unsafe.Pointer(&x.Buffer))
	hxff6bc57.Data = unsafe.Pointer(x.ref997374a2.buffer)
	hxff6bc57.Cap = 0x7fffffff
	// hxff6bc57.Len = ?

}

// allocSoundMemory allocates memory for type C.Sound in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSoundMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSoundValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSoundValue = unsafe.Sizeof([1]C.Sound{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Sound) Ref() *C.Sound {
	if x == nil {
		return nil
	}
	return x.ref394fec80
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Sound) Free() {
	if x != nil && x.allocs394fec80 != nil {
		x.allocs394fec80.(*cgoAllocMap).Free()
		x.ref394fec80 = nil
	}
}

// NewSoundRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSoundRef(ref unsafe.Pointer) *Sound {
	if ref == nil {
		return nil
	}
	obj := new(Sound)
	obj.ref394fec80 = (*C.Sound)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Sound) PassRef() (*C.Sound, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref394fec80 != nil {
		return x.ref394fec80, nil
	}
	mem394fec80 := allocSoundMemory(1)
	ref394fec80 := (*C.Sound)(mem394fec80)
	allocs394fec80 := new(cgoAllocMap)
	allocs394fec80.Add(mem394fec80)

	var csampleCount_allocs *cgoAllocMap
	ref394fec80.sampleCount, csampleCount_allocs = (C.uint)(x.SampleCount), cgoAllocsUnknown
	allocs394fec80.Borrow(csampleCount_allocs)

	var cstream_allocs *cgoAllocMap
	ref394fec80.stream, cstream_allocs = x.Stream.PassValue()
	allocs394fec80.Borrow(cstream_allocs)

	x.ref394fec80 = ref394fec80
	x.allocs394fec80 = allocs394fec80
	return ref394fec80, allocs394fec80

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Sound) PassValue() (C.Sound, *cgoAllocMap) {
	if x.ref394fec80 != nil {
		return *x.ref394fec80, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Sound) Deref() {
	if x.ref394fec80 == nil {
		return
	}
	x.SampleCount = (uint32)(x.ref394fec80.sampleCount)
	x.Stream = *NewAudioStreamRef(unsafe.Pointer(&x.ref394fec80.stream))
}

// allocMusicMemory allocates memory for type C.Music in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMusicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMusicValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMusicValue = unsafe.Sizeof([1]C.Music{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Music) Ref() *C.Music {
	if x == nil {
		return nil
	}
	return x.refc930d4e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Music) Free() {
	if x != nil && x.allocsc930d4e != nil {
		x.allocsc930d4e.(*cgoAllocMap).Free()
		x.refc930d4e = nil
	}
}

// NewMusicRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMusicRef(ref unsafe.Pointer) *Music {
	if ref == nil {
		return nil
	}
	obj := new(Music)
	obj.refc930d4e = (*C.Music)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Music) PassRef() (*C.Music, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc930d4e != nil {
		return x.refc930d4e, nil
	}
	memc930d4e := allocMusicMemory(1)
	refc930d4e := (*C.Music)(memc930d4e)
	allocsc930d4e := new(cgoAllocMap)
	allocsc930d4e.Add(memc930d4e)

	var cctxType_allocs *cgoAllocMap
	refc930d4e.ctxType, cctxType_allocs = (C.int)(x.CtxType), cgoAllocsUnknown
	allocsc930d4e.Borrow(cctxType_allocs)

	var cctxData_allocs *cgoAllocMap
	refc930d4e.ctxData, cctxData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.CtxData)), cgoAllocsUnknown
	allocsc930d4e.Borrow(cctxData_allocs)

	var csampleCount_allocs *cgoAllocMap
	refc930d4e.sampleCount, csampleCount_allocs = (C.uint)(x.SampleCount), cgoAllocsUnknown
	allocsc930d4e.Borrow(csampleCount_allocs)

	var cloopCount_allocs *cgoAllocMap
	refc930d4e.loopCount, cloopCount_allocs = (C.uint)(x.LoopCount), cgoAllocsUnknown
	allocsc930d4e.Borrow(cloopCount_allocs)

	var cstream_allocs *cgoAllocMap
	refc930d4e.stream, cstream_allocs = x.Stream.PassValue()
	allocsc930d4e.Borrow(cstream_allocs)

	x.refc930d4e = refc930d4e
	x.allocsc930d4e = allocsc930d4e
	return refc930d4e, allocsc930d4e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Music) PassValue() (C.Music, *cgoAllocMap) {
	if x.refc930d4e != nil {
		return *x.refc930d4e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Music) Deref() {
	if x.refc930d4e == nil {
		return
	}
	x.CtxType = (int32)(x.refc930d4e.ctxType)
	x.CtxData = (unsafe.Pointer)(unsafe.Pointer(x.refc930d4e.ctxData))
	x.SampleCount = (uint32)(x.refc930d4e.sampleCount)
	x.LoopCount = (uint32)(x.refc930d4e.loopCount)
	x.Stream = *NewAudioStreamRef(unsafe.Pointer(&x.refc930d4e.stream))
}

// allocVrDeviceInfoMemory allocates memory for type C.VrDeviceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVrDeviceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVrDeviceInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVrDeviceInfoValue = unsafe.Sizeof([1]C.VrDeviceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VrDeviceInfo) Ref() *C.VrDeviceInfo {
	if x == nil {
		return nil
	}
	return x.ref6e24e41d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VrDeviceInfo) Free() {
	if x != nil && x.allocs6e24e41d != nil {
		x.allocs6e24e41d.(*cgoAllocMap).Free()
		x.ref6e24e41d = nil
	}
}

// NewVrDeviceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVrDeviceInfoRef(ref unsafe.Pointer) *VrDeviceInfo {
	if ref == nil {
		return nil
	}
	obj := new(VrDeviceInfo)
	obj.ref6e24e41d = (*C.VrDeviceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VrDeviceInfo) PassRef() (*C.VrDeviceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6e24e41d != nil {
		return x.ref6e24e41d, nil
	}
	mem6e24e41d := allocVrDeviceInfoMemory(1)
	ref6e24e41d := (*C.VrDeviceInfo)(mem6e24e41d)
	allocs6e24e41d := new(cgoAllocMap)
	allocs6e24e41d.Add(mem6e24e41d)

	var chResolution_allocs *cgoAllocMap
	ref6e24e41d.hResolution, chResolution_allocs = (C.int)(x.HResolution), cgoAllocsUnknown
	allocs6e24e41d.Borrow(chResolution_allocs)

	var cvResolution_allocs *cgoAllocMap
	ref6e24e41d.vResolution, cvResolution_allocs = (C.int)(x.VResolution), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvResolution_allocs)

	var chScreenSize_allocs *cgoAllocMap
	ref6e24e41d.hScreenSize, chScreenSize_allocs = (C.float)(x.HScreenSize), cgoAllocsUnknown
	allocs6e24e41d.Borrow(chScreenSize_allocs)

	var cvScreenSize_allocs *cgoAllocMap
	ref6e24e41d.vScreenSize, cvScreenSize_allocs = (C.float)(x.VScreenSize), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvScreenSize_allocs)

	var cvScreenCenter_allocs *cgoAllocMap
	ref6e24e41d.vScreenCenter, cvScreenCenter_allocs = (C.float)(x.VScreenCenter), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvScreenCenter_allocs)

	var ceyeToScreenDistance_allocs *cgoAllocMap
	ref6e24e41d.eyeToScreenDistance, ceyeToScreenDistance_allocs = (C.float)(x.EyeToScreenDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(ceyeToScreenDistance_allocs)

	var clensSeparationDistance_allocs *cgoAllocMap
	ref6e24e41d.lensSeparationDistance, clensSeparationDistance_allocs = (C.float)(x.LensSeparationDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(clensSeparationDistance_allocs)

	var cinterpupillaryDistance_allocs *cgoAllocMap
	ref6e24e41d.interpupillaryDistance, cinterpupillaryDistance_allocs = (C.float)(x.InterpupillaryDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cinterpupillaryDistance_allocs)

	var clensDistortionValues_allocs *cgoAllocMap
	ref6e24e41d.lensDistortionValues, clensDistortionValues_allocs = *(*[4]C.float)(unsafe.Pointer(&x.LensDistortionValues)), cgoAllocsUnknown
	allocs6e24e41d.Borrow(clensDistortionValues_allocs)

	var cchromaAbCorrection_allocs *cgoAllocMap
	ref6e24e41d.chromaAbCorrection, cchromaAbCorrection_allocs = *(*[4]C.float)(unsafe.Pointer(&x.ChromaAbCorrection)), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cchromaAbCorrection_allocs)

	x.ref6e24e41d = ref6e24e41d
	x.allocs6e24e41d = allocs6e24e41d
	return ref6e24e41d, allocs6e24e41d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VrDeviceInfo) PassValue() (C.VrDeviceInfo, *cgoAllocMap) {
	if x.ref6e24e41d != nil {
		return *x.ref6e24e41d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VrDeviceInfo) Deref() {
	if x.ref6e24e41d == nil {
		return
	}
	x.HResolution = (int32)(x.ref6e24e41d.hResolution)
	x.VResolution = (int32)(x.ref6e24e41d.vResolution)
	x.HScreenSize = (float32)(x.ref6e24e41d.hScreenSize)
	x.VScreenSize = (float32)(x.ref6e24e41d.vScreenSize)
	x.VScreenCenter = (float32)(x.ref6e24e41d.vScreenCenter)
	x.EyeToScreenDistance = (float32)(x.ref6e24e41d.eyeToScreenDistance)
	x.LensSeparationDistance = (float32)(x.ref6e24e41d.lensSeparationDistance)
	x.InterpupillaryDistance = (float32)(x.ref6e24e41d.interpupillaryDistance)
	x.LensDistortionValues = *(*[4]float32)(unsafe.Pointer(&x.ref6e24e41d.lensDistortionValues))
	x.ChromaAbCorrection = *(*[4]float32)(unsafe.Pointer(&x.ref6e24e41d.chromaAbCorrection))
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		hxf5fa529 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf5fa529.Data = unsafe.Pointer(ptr1)
		hxf5fa529.Cap = 0x7fffffff
		// hxf5fa529.Len = ?
	}
}

// allocCameraMemory allocates memory for type C.Camera in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCameraMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCameraValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCameraValue = unsafe.Sizeof([1]C.Camera{})

// unpackArgSCamera transforms a sliced Go data structure into plain C format.
func unpackArgSCamera(x []Camera) (unpacked *C.Camera, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Camera) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCameraMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Camera)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Camera)(h.Data)
	return
}

// packSCamera reads sliced Go data structure out from plain C format.
func packSCamera(v []Camera, ptr0 *C.Camera) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCameraValue]C.Camera)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCameraRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSVector2 transforms a sliced Go data structure into plain C format.
func unpackArgSVector2(x []Vector2) (unpacked *C.Vector2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Vector2) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVector2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Vector2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Vector2)(h.Data)
	return
}

// packSVector2 reads sliced Go data structure out from plain C format.
func packSVector2(v []Vector2, ptr0 *C.Vector2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVector2Value]C.Vector2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVector2Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSColor transforms a sliced Go data structure into plain C format.
func unpackArgSColor(x []Color) (unpacked *C.Color, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Color) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocColorMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Color)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Color)(h.Data)
	return
}

// packSColor reads sliced Go data structure out from plain C format.
func packSColor(v []Color, ptr0 *C.Color) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfColorValue]C.Color)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewColorRef(unsafe.Pointer(&ptr1))
	}
}

// packSVector4 reads sliced Go data structure out from plain C format.
func packSVector4(v []Vector4, ptr0 *C.Vector4) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVector4Value]C.Vector4)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVector4Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImage transforms a sliced Go data structure into plain C format.
func unpackArgSImage(x []Image) (unpacked *C.Image, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Image) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Image)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Image)(h.Data)
	return
}

// packSImage reads sliced Go data structure out from plain C format.
func packSImage(v []Image, ptr0 *C.Image) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageValue]C.Image)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTexture2D transforms a sliced Go data structure into plain C format.
func unpackArgSTexture2D(x []Texture2D) (unpacked *C.Texture2D, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Texture2D) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocTexture2DMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Texture2D)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Texture2D)(h.Data)
	return
}

// packSTexture2D reads sliced Go data structure out from plain C format.
func packSTexture2D(v []Texture2D, ptr0 *C.Texture2D) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTexture2DValue]C.Texture2D)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTexture2DRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCharInfo transforms a sliced Go data structure into plain C format.
func unpackArgSCharInfo(x []CharInfo) (unpacked *C.CharInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.CharInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCharInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.CharInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.CharInfo)(h.Data)
	return
}

// allocPRectangleMemory allocates memory for type *C.Rectangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPRectangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPRectangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPRectangleValue = unsafe.Sizeof([1]*C.Rectangle{})

// unpackArgSSRectangle transforms a sliced Go data structure into plain C format.
func unpackArgSSRectangle(x [][]Rectangle) (unpacked **C.Rectangle, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.Rectangle) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPRectangleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.Rectangle)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocRectangleMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.Rectangle)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.Rectangle)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.Rectangle)(h.Data)
	return
}

// packSSRectangle reads sliced Go data structure out from plain C format.
func packSSRectangle(v [][]Rectangle, ptr0 **C.Rectangle) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.Rectangle)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfRectangleValue]C.Rectangle)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewRectangleRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// unpackArgSMaterial transforms a sliced Go data structure into plain C format.
func unpackArgSMaterial(x []Material) (unpacked *C.Material, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Material) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMaterialMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Material)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Material)(h.Data)
	return
}

// unpackArgSModel transforms a sliced Go data structure into plain C format.
func unpackArgSModel(x []Model) (unpacked *C.Model, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Model) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocModelMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Model)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Model)(h.Data)
	return
}

// packSModel reads sliced Go data structure out from plain C format.
func packSModel(v []Model, ptr0 *C.Model) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfModelValue]C.Model)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewModelRef(unsafe.Pointer(&ptr1))
	}
}

// packSModelAnimation reads sliced Go data structure out from plain C format.
func packSModelAnimation(v []ModelAnimation, ptr0 *C.ModelAnimation) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfModelAnimationValue]C.ModelAnimation)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewModelAnimationRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMesh transforms a sliced Go data structure into plain C format.
func unpackArgSMesh(x []Mesh) (unpacked *C.Mesh, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Mesh) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMeshMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Mesh)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Mesh)(h.Data)
	return
}

// unpackArgSVector3 transforms a sliced Go data structure into plain C format.
func unpackArgSVector3(x []Vector3) (unpacked *C.Vector3, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Vector3) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVector3Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Vector3)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Vector3)(h.Data)
	return
}

// packSVector3 reads sliced Go data structure out from plain C format.
func packSVector3(v []Vector3, ptr0 *C.Vector3) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVector3Value]C.Vector3)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVector3Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSWave transforms a sliced Go data structure into plain C format.
func unpackArgSWave(x []Wave) (unpacked *C.Wave, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Wave) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocWaveMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Wave)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Wave)(h.Data)
	return
}

// packSWave reads sliced Go data structure out from plain C format.
func packSWave(v []Wave, ptr0 *C.Wave) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfWaveValue]C.Wave)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewWaveRef(unsafe.Pointer(&ptr1))
	}
}
